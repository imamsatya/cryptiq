// Pre-generates all puzzle data and writes to lib/levels/puzzle_data.dart
// Run with: dart run tool/generate_puzzle_data.dart

import 'dart:io';
import 'dart:math';

// Minimal isLetterChar (no external deps)
bool isLetter(String ch) {
  final c = ch.codeUnitAt(0);
  return c >= 65 && c <= 90;
}

// Puzzle data holder
class PuzzleInfo {
  final List<String> operands;
  final String result;
  final String operator;
  final Map<String, int> solution;
  final int difficulty; // 0=easy,1=medium,2=hard,3=expert
  final int uniqueLetters;
  PuzzleInfo(this.operands, this.result, this.operator, this.solution,
      this.difficulty, this.uniqueLetters);
}

void main() {
  print('Generating 1000 puzzles...');
  final sw = Stopwatch()..start();

  final puzzles = <PuzzleInfo>[];
  final rng = Random(42);

  // EASY (250)
  print('  Generating Easy...');
  mixedBatch(puzzles, rng, 10, 1, 1, 1, 9, 0, '+');
  mixedBatch(puzzles, rng, 25, 1, 1, 10, 50, 0, '+');
  mixedBatch(puzzles, rng, 40, 2, 2, 10, 99, 0, '+');
  mixedBatch(puzzles, rng, 60, 2, 3, 10, 99, 0, '+');
  mixedBatch(puzzles, rng, 80, 3, 3, 10, 99, 0, '+');
  mixedBatch(puzzles, rng, 105, 3, 4, 10, 999, 0, '+');
  fullBatch(puzzles, rng, 130, 0, 100, 999, 4, 5, '+');
  mixedBatch(puzzles, rng, 145, 1, 2, 1, 50, 0, '-');
  mixedBatch(puzzles, rng, 160, 2, 3, 10, 99, 0, '-');
  mixedBatch(puzzles, rng, 180, 3, 4, 10, 99, 0, '-');
  fullBatch(puzzles, rng, 200, 0, 10, 999, 3, 5, '-');
  fullBatch(puzzles, rng, 225, 0, 100, 999, 4, 5, '+');
  fullBatch(puzzles, rng, 250, 0, 100, 999, 4, 5, '-');
  print('    Easy: ${puzzles.length} puzzles');

  // MEDIUM (250)
  print('  Generating Medium...');
  fullBatch(puzzles, rng, 290, 1, 100, 999, 5, 6, '+');
  fullBatch(puzzles, rng, 330, 1, 100, 999, 5, 6, '-');
  mixedBatch(puzzles, rng, 350, 1, 2, 2, 9, 1, '×');
  mixedBatch(puzzles, rng, 370, 2, 3, 2, 20, 1, '×');
  fullBatch(puzzles, rng, 390, 1, 2, 30, 3, 5, '×');
  fullBatch(puzzles, rng, 420, 1, 100, 9999, 5, 7, '+');
  curated(puzzles, ['TWO', 'TWO'], 'FOUR',
      {'T': 7, 'W': 3, 'O': 4, 'F': 1, 'U': 6, 'R': 8}, 1, '+');
  fullBatch(puzzles, rng, 460, 1, 100, 9999, 5, 7, '-');
  fullBatch(puzzles, rng, 500, 1, 10, 99, 4, 6, '×');
  print('    Medium: ${puzzles.length} puzzles');

  // HARD (250)
  print('  Generating Hard...');
  fullBatch(puzzles, rng, 540, 2, 100, 9999, 6, 8, '+');
  curated(puzzles, ['SEND', 'MORE'], 'MONEY',
      {'S': 9, 'E': 5, 'N': 6, 'D': 7, 'M': 1, 'O': 0, 'R': 8, 'Y': 2}, 2, '+');
  fullBatch(puzzles, rng, 590, 2, 100, 9999, 6, 8, '-');
  fullBatch(puzzles, rng, 630, 2, 10, 999, 5, 7, '×');
  fullBatch(puzzles, rng, 690, 2, 100, 99999, 7, 8, '+');
  fullBatch(puzzles, rng, 750, 2, 100, 99999, 7, 8, '-');
  print('    Hard: ${puzzles.length} puzzles');

  // EXPERT (250)
  print('  Generating Expert...');
  fullBatch(puzzles, rng, 820, 3, 1000, 99999, 7, 9, '+');
  fullBatch(puzzles, rng, 880, 3, 1000, 99999, 7, 9, '-');
  fullBatch(puzzles, rng, 920, 3, 10, 9999, 6, 7, '×');
  curated(puzzles, ['FORTY', 'TEN', 'TEN'], 'SIXTY',
      {'F': 2, 'O': 9, 'R': 7, 'T': 8, 'Y': 6, 'E': 5, 'N': 0, 'S': 3, 'I': 1, 'X': 4}, 3, '+');
  curated(puzzles, ['DONALD', 'GERALD'], 'ROBERT',
      {'D': 5, 'O': 2, 'N': 6, 'A': 4, 'L': 8, 'G': 1, 'E': 9, 'R': 7, 'B': 3, 'T': 0}, 3, '+');
  fullBatch(puzzles, rng, 960, 3, 1000, 99999, 8, 10, '+');
  fullBatch(puzzles, rng, 1000, 3, 1000, 99999, 8, 10, '-');
  print('    Expert: ${puzzles.length} puzzles');

  sw.stop();
  print('Generated ${puzzles.length} puzzles in ${sw.elapsed.inSeconds}s');

  // Write output
  final buf = StringBuffer();
  buf.writeln('// AUTO-GENERATED by tool/generate_puzzle_data.dart — DO NOT EDIT');
  buf.writeln('// Regenerate: dart run tool/generate_puzzle_data.dart');
  buf.writeln('//');
  buf.writeln('// ${puzzles.length} puzzles with verified unique solutions');
  buf.writeln('// Operations: +, -, ×');
  buf.writeln('');
  buf.writeln('/// Pre-computed puzzle data [operands, result, operator, solution, difficulty, uniqueLetters]');
  buf.writeln('const puzzleData = <List<dynamic>>[');
  for (int i = 0; i < puzzles.length; i++) {
    final p = puzzles[i];
    final ops = p.operands.map((o) => "'$o'").join(', ');
    final sol = p.solution.entries.map((e) => "'${e.key}': ${e.value}").join(', ');
    buf.writeln("  [[$ops], '${p.result}', '${p.operator}', {$sol}, ${p.difficulty}, ${p.uniqueLetters}],");
  }
  buf.writeln('];');

  File('lib/levels/puzzle_data.dart').writeAsStringSync(buf.toString());
  print('Written to lib/levels/puzzle_data.dart');
}

// ================================================================
// Generation logic (self-contained, no external dependencies)
// ================================================================

void curated(List<PuzzleInfo> p, List<String> ops, String res,
    Map<String, int> sol, int diff, String op) {
  p.add(PuzzleInfo(ops, res, op, sol, diff, sol.length));
}

void mixedBatch(List<PuzzleInfo> p, Random rng, int target,
    int minL, int maxL, int minV, int maxV, int diff, String op) {
  int fail = 0;
  while (p.length < target && fail < 50000) {
    final r = genMixed(rng, minL, maxL, minV, maxV, diff, op);
    if (r != null && !isDup(p, r)) {
      if (hasUnique(r.operands, r.result, op)) {
        p.add(r);
        fail = 0;
      } else {
        fail++;
      }
    } else {
      fail++;
    }
  }
}

PuzzleInfo? genMixed(Random rng, int minL, int maxL, int minV, int maxV, int diff, String op) {
  for (int attempt = 0; attempt < 500; attempt++) {
    int a, b, c;
    List<String> operands;
    String result;
    if (op == '+') {
      a = minV + rng.nextInt(maxV - minV + 1);
      b = minV + rng.nextInt(maxV - minV + 1);
      c = a + b;
      operands = ['$a', '$b'];
      result = '$c';
    } else if (op == '-') {
      a = minV + rng.nextInt(maxV - minV + 1);
      b = minV + rng.nextInt(maxV - minV + 1);
      c = a + b;
      operands = ['$c', '$a'];
      result = '$b';
    } else {
      final aMin = minV < 2 ? 2 : minV;
      final bMax = maxV < 9 ? maxV : 9;
      a = aMin + rng.nextInt((maxV - aMin + 1).clamp(1, 999999));
      b = 2 + rng.nextInt((bMax - 2 + 1).clamp(1, 8));
      if (a < b) { final t = a; a = b; b = t; }
      c = a * b;
      operands = ['$a', '$b'];
      result = '$c';
    }
    if (result[0] == '0') continue;
    final allChars = <String>{};
    for (final o in operands) { allChars.addAll(o.split('')); }
    allChars.addAll(result.split(''));
    final uniqueDigits = allChars.map(int.parse).toSet().toList();
    final targetL = minL + rng.nextInt(maxL - minL + 1);
    if (uniqueDigits.length < targetL) continue;
    uniqueDigits.shuffle(rng);
    final lettered = uniqueDigits.take(targetL).toSet();
    final d2l = <int, String>{};
    final pool = letterPool(rng);
    int li = 0;
    for (final d in lettered) { d2l[d] = pool[li++]; }
    String convert(String s) => s.split('').map((ch) {
      final d = int.parse(ch);
      return d2l.containsKey(d) ? d2l[d]! : ch;
    }).join();
    final words = operands.map(convert).toList();
    final wordRes = convert(result);
    final sol = <String, int>{};
    for (final e in d2l.entries) { sol[e.value] = e.key; }
    bool bad = false;
    for (final w in [...words, wordRes]) {
      if (w.length > 1 && isLetter(w[0]) && sol[w[0]] == 0) { bad = true; break; }
    }
    if (bad) continue;
    return PuzzleInfo(words, wordRes, op, sol, diff, sol.length);
  }
  return null;
}

void fullBatch(List<PuzzleInfo> p, Random rng, int target, int diff,
    int minV, int maxV, int minL, int maxL, String op) {
  int fail = 0;
  while (p.length < target && fail < 100000) {
    final r = genFull(rng, diff, minV, maxV, minL, maxL, op);
    if (r != null && !isDup(p, r)) {
      if (hasUnique(r.operands, r.result, op)) {
        p.add(r);
        fail = 0;
      } else {
        fail++;
      }
    } else {
      fail++;
    }
  }
}

PuzzleInfo? genFull(Random rng, int diff, int minV, int maxV, int minL, int maxL, String op) {
  for (int attempt = 0; attempt < 200; attempt++) {
    int a, b, c;
    List<String> numOps;
    String numRes;
    if (op == '+') {
      a = minV + rng.nextInt(maxV - minV + 1);
      b = minV + rng.nextInt(maxV - minV + 1);
      c = a + b;
      numOps = ['$a', '$b'];
      numRes = '$c';
    } else if (op == '-') {
      a = minV + rng.nextInt(maxV - minV + 1);
      b = minV + rng.nextInt(maxV - minV + 1);
      c = a + b;
      numOps = ['$c', '$a'];
      numRes = '$b';
    } else {
      final aMin = minV < 2 ? 2 : minV;
      final bMax = (maxV ~/ 10) < 2 ? 2 : (maxV ~/ 10 < 9 ? maxV ~/ 10 : 9);
      a = aMin + rng.nextInt((maxV - aMin + 1).clamp(1, 999999));
      b = 2 + rng.nextInt((bMax - 2 + 1).clamp(1, 8));
      if (a < b) { final t = a; a = b; b = t; }
      c = a * b;
      numOps = ['$a', '$b'];
      numRes = '$c';
    }
    if (numRes[0] == '0') continue;
    final allDigits = <int>{};
    for (final s in [...numOps, numRes]) {
      for (final ch in s.split('')) { allDigits.add(int.parse(ch)); }
    }
    if (allDigits.length < minL || allDigits.length > maxL) continue;
    if (allDigits.length > 10) continue;
    final d2l = <int, String>{};
    final pool = letterPool(rng);
    int li = 0;
    for (final d in allDigits.toList()..sort()) { d2l[d] = pool[li++]; }
    final sol = <String, int>{};
    for (final e in d2l.entries) { sol[e.value] = e.key; }
    String toWord(String s) => s.split('').map((ch) => d2l[int.parse(ch)]!).join();
    final words = numOps.map(toWord).toList();
    final wordRes = toWord(numRes);
    bool bad = false;
    for (final w in [...words, wordRes]) {
      if (w.length > 1 && sol[w[0]] == 0) { bad = true; break; }
    }
    if (bad) continue;
    return PuzzleInfo(words, wordRes, op, sol, diff, sol.length);
  }
  return null;
}

bool isDup(List<PuzzleInfo> existing, PuzzleInfo p) {
  for (final e in existing) {
    if (e.operands.join() == p.operands.join() && e.result == p.result && e.operator == p.operator) return true;
  }
  return false;
}

List<String> letterPool(Random rng) {
  final pools = ['ABCDEFGHIJ','KLMNOPQRST','UVWXYZABCD','ACEGIKMOQS','BDFHJLNPRT','STNRLOAEIM','PWGYHBKDCF','MRJXZQVWUE'];
  final pool = pools[rng.nextInt(pools.length)].split('');
  pool.shuffle(rng);
  return pool;
}

// ================================================================
// Solvers
// ================================================================

bool hasUnique(List<String> ops, String res, String op) {
  if (op == '+') return countAdd(ops, res, 2) == 1;
  if (op == '-') return countAdd([ops[1], res], ops[0], 2) == 1;
  return countBrute(ops, res, op, 2) == 1;
}

int countAdd(List<String> operands, String result, int maxCount) {
  final letterSet = <String>{};
  for (final op in operands) { for (final ch in op.split('')) { if (isLetter(ch)) letterSet.add(ch); } }
  for (final ch in result.split('')) { if (isLetter(ch)) letterSet.add(ch); }
  final letters = letterSet.toList()..sort();
  final n = letters.length;
  if (n == 0) { return checkFixed(operands, result, '+') ? 1 : 0; }
  if (n > 10) return 0;
  final lIdx = <String, int>{};
  for (int i = 0; i < n; i++) { lIdx[letters[i]] = i; }
  final isLead = List.filled(n, false);
  for (final op in operands) { if (op.length > 1 && isLetter(op[0])) isLead[lIdx[op[0]]!] = true; }
  if (result.length > 1 && isLetter(result[0])) isLead[lIdx[result[0]]!] = true;
  int maxLen = result.length;
  for (final op in operands) { if (op.length > maxLen) maxLen = op.length; }
  final opCols = <List<int>>[];
  final resCols = <int>[];
  for (int col = 0; col < maxLen; col++) {
    final entries = <int>[];
    for (final op in operands) {
      final pos = op.length - 1 - col;
      if (pos >= 0) { final ch = op[pos]; entries.add(isLetter(ch) ? lIdx[ch]! : -(int.parse(ch) + 1)); }
    }
    final resPos = result.length - 1 - col;
    int resEntry;
    if (resPos >= 0) { final ch = result[resPos]; resEntry = isLetter(ch) ? lIdx[ch]! : -(int.parse(ch) + 1); }
    else { resEntry = -1; }
    opCols.add(entries);
    resCols.add(resEntry);
  }
  final priority = List.filled(n, maxLen + 1);
  for (int col = 0; col < opCols.length; col++) {
    for (final e in opCols[col]) { if (e >= 0 && col < priority[e]) priority[e] = col; }
    if (resCols[col] >= 0 && col < priority[resCols[col]]) priority[resCols[col]] = col;
  }
  final order = List.generate(n, (i) => i);
  order.sort((a, b) => priority[a].compareTo(priority[b]));
  final asgn = List.filled(n, -1);
  final used = List.filled(10, false);
  int count = 0;
  int dig(int enc) => enc >= 0 ? asgn[enc] : -(enc + 1);
  bool partial() {
    int carry = 0;
    for (int col = 0; col < opCols.length; col++) {
      bool allSet = true;
      for (final e in opCols[col]) { if (e >= 0 && asgn[e] < 0) { allSet = false; break; } }
      if (resCols[col] >= 0 && asgn[resCols[col]] < 0) allSet = false;
      if (!allSet) break;
      int s = carry;
      for (final e in opCols[col]) { s += dig(e); }
      if (s % 10 != dig(resCols[col])) return false;
      carry = s ~/ 10;
    }
    return true;
  }
  void solve(int depth) {
    if (count >= maxCount) return;
    if (depth == n) {
      int carry = 0;
      for (int col = 0; col < opCols.length; col++) {
        int s = carry;
        for (final e in opCols[col]) { s += dig(e); }
        if (s % 10 != dig(resCols[col])) return;
        carry = s ~/ 10;
      }
      if (carry != 0) return;
      count++;
      return;
    }
    final li = order[depth];
    for (int d = isLead[li] ? 1 : 0; d <= 9; d++) {
      if (used[d]) continue;
      asgn[li] = d; used[d] = true;
      if (partial()) solve(depth + 1);
      asgn[li] = -1; used[d] = false;
      if (count >= maxCount) return;
    }
  }
  solve(0);
  return count;
}

int countBrute(List<String> operands, String result, String op, int maxCount) {
  final letterSet = <String>{};
  for (final o in operands) { for (final ch in o.split('')) { if (isLetter(ch)) letterSet.add(ch); } }
  for (final ch in result.split('')) { if (isLetter(ch)) letterSet.add(ch); }
  final letters = letterSet.toList()..sort();
  final n = letters.length;
  if (n == 0) return checkFixed(operands, result, op) ? 1 : 0;
  if (n > 10) return 0;
  final leading = <String>{};
  for (final o in operands) { if (o.length > 1 && isLetter(o[0])) leading.add(o[0]); }
  if (result.length > 1 && isLetter(result[0])) leading.add(result[0]);
  int count = 0;
  final asgn = List.filled(n, -1);
  final used = List.filled(10, false);
  void solve(int depth) {
    if (count >= maxCount) return;
    if (depth == n) {
      final m = <String, int>{};
      for (int i = 0; i < n; i++) { m[letters[i]] = asgn[i]; }
      int w2n(String w) { int v = 0; for (final ch in w.split('')) { v = v * 10 + (isLetter(ch) ? m[ch]! : int.parse(ch)); } return v; }
      final opVals = operands.map(w2n).toList();
      final resVal = w2n(result);
      bool valid;
      if (op == '×') { valid = opVals.reduce((a, b) => a * b) == resVal; }
      else if (op == '-') { valid = opVals.first - opVals.skip(1).reduce((a, b) => a + b) == resVal; }
      else { valid = opVals.reduce((a, b) => a + b) == resVal; }
      if (valid) count++;
      return;
    }
    final letter = letters[depth];
    for (int d = leading.contains(letter) ? 1 : 0; d <= 9; d++) {
      if (used[d]) continue;
      asgn[depth] = d; used[d] = true;
      solve(depth + 1);
      used[d] = false;
      if (count >= maxCount) return;
    }
  }
  solve(0);
  return count;
}

bool checkFixed(List<String> operands, String result, String op) {
  int w2n(String w) { int v = 0; for (final ch in w.split('')) { v = v * 10 + int.parse(ch); } return v; }
  final opVals = operands.map(w2n).toList();
  final resVal = w2n(result);
  if (op == '×') return opVals.reduce((a, b) => a * b) == resVal;
  if (op == '-') return opVals.first - opVals.skip(1).reduce((a, b) => a + b) == resVal;
  return opVals.reduce((a, b) => a + b) == resVal;
}
